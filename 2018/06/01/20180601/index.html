<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nealwangzi.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="1.class 和 struct 的区别class 是引用类型，struct 是值类型 2.不通过继承，代码复用（共享）的方式有哪些extension 给已有类扩展方法 3.set 独有的方法有哪些123456789101112131415&#x2F;&#x2F;定义一个 setlet setA: Set&lt;Int&gt; &#x3D; [1,2,3,4,3] &#x2F;&#x2F; &amp;#123;2,3,1,4&amp;#125;,顺序可能不一致，">
<meta property="og:type" content="article">
<meta property="og:title" content="swift 面试题">
<meta property="og:url" content="https://nealwangzi.github.io/2018/06/01/20180601/index.html">
<meta property="og:site_name" content="安东尼的博客">
<meta property="og:description" content="1.class 和 struct 的区别class 是引用类型，struct 是值类型 2.不通过继承，代码复用（共享）的方式有哪些extension 给已有类扩展方法 3.set 独有的方法有哪些123456789101112131415&#x2F;&#x2F;定义一个 setlet setA: Set&lt;Int&gt; &#x3D; [1,2,3,4,3] &#x2F;&#x2F; &amp;#123;2,3,1,4&amp;#125;,顺序可能不一致，">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-06-01T06:32:42.000Z">
<meta property="article:modified_time" content="2018-06-06T06:49:19.000Z">
<meta property="article:author" content="neal">
<meta property="article:tag" content="swift">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://nealwangzi.github.io/2018/06/01/20180601/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>swift 面试题 | 安东尼的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">安东尼的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://nealwangzi.github.io/2018/06/01/20180601/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="neal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="安东尼的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          swift 面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-01 14:32:42" itemprop="dateCreated datePublished" datetime="2018-06-01T14:32:42+08:00">2018-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2018-06-06 14:49:19" itemprop="dateModified" datetime="2018-06-06T14:49:19+08:00">2018-06-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="1-class-和-struct-的区别"><a href="#1-class-和-struct-的区别" class="headerlink" title="1.class 和 struct 的区别"></a>1.class 和 struct 的区别</h3><p>class 是引用类型，struct 是值类型</p>
<h3 id="2-不通过继承，代码复用（共享）的方式有哪些"><a href="#2-不通过继承，代码复用（共享）的方式有哪些" class="headerlink" title="2.不通过继承，代码复用（共享）的方式有哪些"></a>2.不通过继承，代码复用（共享）的方式有哪些</h3><p>extension 给已有类扩展方法</p>
<h3 id="3-set-独有的方法有哪些"><a href="#3-set-独有的方法有哪些" class="headerlink" title="3.set 独有的方法有哪些"></a>3.set 独有的方法有哪些</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//定义一个 set</span><br><span class="line">let setA: Set&lt;Int&gt; = [1,2,3,4,3] // &#123;2,3,1,4&#125;,顺序可能不一致，同一个元素只能有一个值</span><br><span class="line">let setB: Set&lt;Int&gt; = [1,3,5,7,9] // &#123;5,7,3,1,9&#125;</span><br><span class="line"></span><br><span class="line">//取并集 A|B</span><br><span class="line">let setUnion = setA.union(setB) // &#123;2,4,9,5,7,3,1&#125;</span><br><span class="line"></span><br><span class="line">//取交集 A&amp;B</span><br><span class="line">let setIntersect = setA.intersection(setB) // &#123;3,1&#125;</span><br><span class="line"></span><br><span class="line">//取差集 A-B</span><br><span class="line">let setRevers = setA.subtracting(setB) // &#123;2,4&#125;</span><br><span class="line"></span><br><span class="line">//取对称差集 A XOR B = A-B | B-A</span><br><span class="line">let setXor = setA.symmetricDifference(setB) // &#123;5,7,2,4,9&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-实现一个-min-函数，返回两个元素较小的元素"><a href="#4-实现一个-min-函数，返回两个元素较小的元素" class="headerlink" title="4.实现一个 min 函数，返回两个元素较小的元素"></a>4.实现一个 min 函数，返回两个元素较小的元素</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func min&lt;T : Comparable&gt;(_ a:T,_ b:T) -&gt; T &#123;</span><br><span class="line">    return a &lt; b ? a : b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">min(1, 2)</span><br></pre></td></tr></table></figure>

<h3 id="5-map、filter、reduce-的作用"><a href="#5-map、filter、reduce-的作用" class="headerlink" title="5.map、filter、reduce 的作用"></a>5.map、filter、reduce 的作用</h3><ul>
<li>map:映射，讲一个元素根据某个函数映射成另一个元素（类型可以不同）</li>
<li>filter:过滤，将一个元素传入闭包中，如果返回的是false，就过滤掉</li>
<li>reduce:先映射后融合，将数组中的所有元素映射融合一起。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    let name: String</span><br><span class="line">    let money: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = Person(name: &quot;a&quot;, money: &quot;1.99&quot;)</span><br><span class="line">let b = Person(name: &quot;b&quot;, money: &quot;7.19&quot;)</span><br><span class="line">let c = Person(name: &quot;c&quot;, money: &quot;3.22&quot;)</span><br><span class="line"></span><br><span class="line">let sumMoney = [a,b,c].reduce(0) &#123;</span><br><span class="line">    return $0 + ($1.money as NSString).doubleValue</span><br><span class="line">&#125;</span><br><span class="line">print(sumMoney)</span><br></pre></td></tr></table></figure>

<h3 id="6-map-与-flatmap-的区别"><a href="#6-map-与-flatmap-的区别" class="headerlink" title="6.map 与 flatmap 的区别"></a>6.map 与 flatmap 的区别</h3><p>map不能将元素映射成可选类型，flatmap 可以</p>
<h3 id="7-什么是-copy-on-write"><a href="#7-什么是-copy-on-write" class="headerlink" title="7.什么是 copy on write"></a>7.什么是 copy on write</h3><p>写入时复制指swift中值类型。不会再一开始赋值的时候就去复制，只要在需要修改的时候才去复制。</p>
<h3 id="8-如何获取当前代码的函数名和行号"><a href="#8-如何获取当前代码的函数名和行号" class="headerlink" title="8.如何获取当前代码的函数名和行号"></a>8.如何获取当前代码的函数名和行号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#file 用于获取当前文件文件名</span><br><span class="line">#line 用于获取当前行号</span><br><span class="line">#column 用于获取当前列编号</span><br><span class="line">#function 用于获取当前函数名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-如何生命一个只能被类-conform-的-protocol"><a href="#9-如何生命一个只能被类-conform-的-protocol" class="headerlink" title="9.如何生命一个只能被类 conform 的 protocol"></a>9.如何生命一个只能被类 conform 的 protocol</h3><p>声明协议的时候，加上 class 即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protocol SomeClassProtocl: class &#123;</span><br><span class="line">    func someFunction()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-guard-使用场景"><a href="#10-guard-使用场景" class="headerlink" title="10. guard 使用场景"></a>10. guard 使用场景</h3><p>guard 和 if 类似，不同在于 gurad 总是有个 else 语句，如果表达式为 false,或者值绑定失败时，会执行 else 语句中一定要停止函数调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">guard 1 + 1 == 2 else &#123;</span><br><span class="line">    fatalError(&quot;something wrong&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要用于 拦截，解包，不满足 guard 后面条件的都会执行下面的代码</p>
<h3 id="11-defer-使用场景"><a href="#11-defer-使用场景" class="headerlink" title="11. defer 使用场景"></a>11. defer 使用场景</h3><p>defer 语句块中的代码，会在当前作用域结束前调用，常用场景如异常退出后，关闭数据库连接</p>
<p>需要注意的是，如果有多个defer，那么后加入的先执行</p>
<h3 id="12-String-与-NSString-的关系和区别"><a href="#12-String-与-NSString-的关系和区别" class="headerlink" title="12. String 与 NSString 的关系和区别"></a>12. String 与 NSString 的关系和区别</h3><p>String 是结构体，值类型; NSString 是类，引用类型<br>通常，没必要使用 NSString 类，除非有特殊方法，例如使用 pathExtension 属性</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let string = &quot;1234&quot;</span><br><span class="line">let nsstring = NSString(string: &quot;n1234&quot;)</span><br><span class="line"></span><br><span class="line">let stringToNSString = string as NSString</span><br><span class="line">let nsstringToString = nsstring as String</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="13-怎么获取一个-String-的长度"><a href="#13-怎么获取一个-String-的长度" class="headerlink" title="13.怎么获取一个 String 的长度"></a>13.怎么获取一个 String 的长度</h3><p>不考虑编码，只想知道字符的数量 用 characters.count</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot;.count</span><br><span class="line">&quot;你好&quot;.count</span><br><span class="line">&quot;こんにちは&quot;.count</span><br></pre></td></tr></table></figure>
<p>如果想知道在某个编码下占多少字节, 可以用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot;.lengthOfBytes(using: .ascii) // 5</span><br><span class="line">&quot;hello&quot;.lengthOfBytes(using: .unicode) // 10</span><br><span class="line">&quot;你好&quot;.lengthOfBytes(using: .unicode) // 4</span><br><span class="line">&quot;你好&quot;.lengthOfBytes(using: .utf8) // 6</span><br><span class="line">&quot;こんにちは&quot;.lengthOfBytes(using: .unicode) // 10</span><br><span class="line">&quot;こんにちは&quot;.lengthOfBytes(using: .utf8) // 15</span><br></pre></td></tr></table></figure>

<h3 id="14-如何截取-String-的某段字符串"><a href="#14-如何截取-String-的某段字符串" class="headerlink" title="14.如何截取 String 的某段字符串"></a>14.如何截取 String 的某段字符串</h3><p>swfit3 中，有三个取子串函数<br>substring:to ;substring:from ; substring:with 已废弃</p>
<p>swfit4 使用下标将字符串分割子字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 获取从指定索引到末尾子字符串</span><br><span class="line"></span><br><span class="line">let simpleString = &quot;hello, world&quot;</span><br><span class="line"></span><br><span class="line">let indexStartText = simpleString.index(simpleString.startIndex, offsetBy: 3)</span><br><span class="line"></span><br><span class="line">let indexEndText = simpleString.index(simpleString.endIndex, offsetBy: -3)</span><br><span class="line"></span><br><span class="line">let substring1 = simpleString[indexStartText...]</span><br><span class="line"></span><br><span class="line">// 获取从开头到指定索引的子字符串</span><br><span class="line"></span><br><span class="line">let substring2 = simpleString[..&lt;indexEndText]</span><br><span class="line">// 获取指定范围子字符串</span><br><span class="line">let substring3 = simpleString[indexStartText..&lt;indexEndText]</span><br><span class="line"></span><br><span class="line">// Substring 转 String</span><br><span class="line">let string1 = String(substring1)</span><br></pre></td></tr></table></figure>

<h3 id="15-throws-和-rethrows-的用法与作用"><a href="#15-throws-和-rethrows-的用法与作用" class="headerlink" title="15. throws 和 rethrows 的用法与作用"></a>15. throws 和 rethrows 的用法与作用</h3><p>throws 用在函数上，表示这个函数会抛出错误<br>有两种情况，一种直接使用 throw 抛出，另一种调用其他抛出异常的函数时，直接使用try xx 没有处理异常</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum DivideError: Error &#123;</span><br><span class="line">    case EqualZeroError;</span><br><span class="line">&#125;</span><br><span class="line">func divide(_ a: Double, _ b : Double) throws -&gt; Double &#123;</span><br><span class="line">    guard b != Double(0) else &#123;</span><br><span class="line">        throw DivideError.EqualZeroError</span><br><span class="line">    &#125;</span><br><span class="line">    return a / b</span><br><span class="line">&#125;</span><br><span class="line">func split(pieces: Int) throws -&gt; Double &#123;</span><br><span class="line">    return try divide(1, Double(pieces))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>rethrows 与 throws 类似，不过只适用于参数中的函数，且函数会抛出异常情况，rethrows 可以用 throws 替换，反之不行。</p>
<h3 id="16-try-和-try！是什么意思"><a href="#16-try-和-try！是什么意思" class="headerlink" title="16.try? 和 try！是什么意思"></a>16.try? 和 try！是什么意思</h3><p>都是用于处理可抛出异常的函数，使用这两个关键词可以不用写 do catch</p>
<p>try! 强制抛出错误，有错误就崩溃；<br>try? 抛出错误，没有错误不会崩溃直接返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(try? divide(2, 1)) // Optional(2.0)</span><br><span class="line"></span><br><span class="line">print(try? divide(2, 0)) // nil</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="17-associatedtype-的作用"><a href="#17-associatedtype-的作用" class="headerlink" title="17. associatedtype 的作用"></a>17. associatedtype 的作用</h3><p>简而言之是 protocol 使用的泛型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个列表协议</span><br><span class="line">protocol ListProtcol &#123;</span><br><span class="line">    associatedtype Element</span><br><span class="line">    func push(_ element: Element)</span><br><span class="line">    func pop(_ element: Element) -&gt; Element?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 协议实现是，可以使用 typealias 指定为特定类型，也可以自动推导</span><br><span class="line"></span><br><span class="line">class IntList: ListProtcol &#123;</span><br><span class="line">    typealias Element = Int // 指定为 Int</span><br><span class="line">    var list = [Element]()</span><br><span class="line">    func push(_ element: Int) &#123;</span><br><span class="line">        self.list.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop(_ element: Int) -&gt; Int? &#123;</span><br><span class="line">        return self.list.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DoubleList: ListProtcol &#123;</span><br><span class="line">    var list = [Double]()</span><br><span class="line">    func push(_ element: Double) &#123;// 自动推断</span><br><span class="line">        self.list.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop(_ element: Double) -&gt; Double? &#123;</span><br><span class="line">        return self.list.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用使用泛型 </span><br><span class="line">class AnyList&lt;T&gt;: ListProtcol &#123;</span><br><span class="line">    var list = [T]()</span><br><span class="line">    func push(_ element: T) &#123;</span><br><span class="line">        self.list.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    func pop(_ element: T) -&gt; T? &#123;</span><br><span class="line">        return self.list.popLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 可以使用 where 字句限定 Element 类型</span><br><span class="line">extension ListProtcol where Element == Int &#123;</span><br><span class="line">    func isInt() -&gt;Bool &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-什么时候使用-final"><a href="#18-什么时候使用-final" class="headerlink" title="18.什么时候使用 final"></a>18.什么时候使用 final</h3><p>final 用于限制继承和重写。<br>例如 final var, final func, final class func, 和 final subscript<br>也可以限制整个类，在 class 前面 加上 final</p>
<h3 id="19-public-和-open-的区别"><a href="#19-public-和-open-的区别" class="headerlink" title="19.public 和 open 的区别"></a>19.public 和 open 的区别</h3><p>这两个都是用于模块中生命需要对外暴露的函数。区别在于： public 修饰的类，在模块外，无法继承； open 则可以任何继承。公开度来说，public &lt; open</p>
<h3 id="20-生命一个只有一个参数没有返回值闭包的别名"><a href="#20-生命一个只有一个参数没有返回值闭包的别名" class="headerlink" title="20.生命一个只有一个参数没有返回值闭包的别名"></a>20.生命一个只有一个参数没有返回值闭包的别名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typealias SomeClosureType = (String) -&gt; (Void)</span><br><span class="line">let someClosure: SomeClosureType = &#123; (name) in</span><br><span class="line">    print(&quot;hello &quot;, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SomeClosureType(&quot;world&quot;)</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>

<h3 id="21-Self-的使用场景"><a href="#21-Self-的使用场景" class="headerlink" title="21.Self 的使用场景"></a>21.Self 的使用场景</h3><p>self 通常在协议中使用，用来表示实现者或者是实现者的子类类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个复制协议</span><br><span class="line">protocol CopyProtocol &#123;</span><br><span class="line">    func copy() -&gt; Self</span><br><span class="line">&#125;</span><br><span class="line">// 结构体实现，将 self 换为具体的类型</span><br><span class="line">struct SomeStruct: CopyProtocol &#123;</span><br><span class="line">    let value: Int</span><br><span class="line">    func copy() -&gt; SomeStruct &#123;</span><br><span class="line">        return SomeStruct(value: self.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 类实现，有点复杂，需要一个 required 的初始化方法</span><br><span class="line">class SomeCopyableClass: CopyProtocol &#123;</span><br><span class="line">    func copy() -&gt; Self &#123;</span><br><span class="line">        return type(of: self).init()</span><br><span class="line">    &#125;</span><br><span class="line">    required init()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="22-Dynamic-的作用"><a href="#22-Dynamic-的作用" class="headerlink" title="22.Dynamic 的作用"></a>22.Dynamic 的作用</h3><p>由于 swift 是一个静态语言, 所以没有 Objective-C 中的消息发送这些动态机制, dynamic 的作用就是让 swift 代码也能有 Objective-C 中的动态机制, 常用的地方就是 KVO 了, 如果要监控一个属性, 则必须要标记为 dynamic。</p>
<h3 id="23-什么时候使用-objc"><a href="#23-什么时候使用-objc" class="headerlink" title="23.什么时候使用 @objc"></a>23.什么时候使用 @objc</h3><p>@objc 用于在 Objective-C 和 Swfit 混编时，正常调用 swfit 代码。可以用于修饰类，协议，方法，属性<br>常用与 delegate 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@objc protocol OptionalProtocol &#123;</span><br><span class="line">    @objc optional func optionalFunc()</span><br><span class="line">    func normalFunc()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class OptionalProtocolClass: OptionalProtocol &#123;</span><br><span class="line">    func normalFunc() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let someOptionalDelegate: OptionalProtocol = OptionalProtocolClass()</span><br><span class="line"></span><br><span class="line">someOptionalDelegate.optionalFunc?()</span><br></pre></td></tr></table></figure>

<h3 id="24-Optional-是怎么实现的"><a href="#24-Optional-是怎么实现的" class="headerlink" title="24.Optional 是怎么实现的"></a>24.Optional 是怎么实现的</h3><p>optional 是一个泛型枚举<br>定义如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum Optional&lt;Wrapped&gt; &#123;</span><br><span class="line">    case none</span><br><span class="line">    case some(Wrapped)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了使用 let someValue: Int? &#x3D; nil 之外，还可以 使用 let optinal1: Optional &#x3D; nil 来定义</p>
<h3 id="25-如何自定义下标获取"><a href="#25-如何自定义下标获取" class="headerlink" title="25.如何自定义下标获取"></a>25.如何自定义下标获取</h3><p>实现 subscript 即可， 如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extension AnyList &#123;</span><br><span class="line">    subscript(index: Int) -&gt; T &#123;</span><br><span class="line">        return self.list[index]</span><br><span class="line">    &#125;</span><br><span class="line">    subscript(indexString: String) -&gt; T? &#123;</span><br><span class="line">        guard let index = Int(indexString) else &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        return self.list[index]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>索引除了数字之外，其他类型也是可以的</p>
<h3 id="26-的作用"><a href="#26-的作用" class="headerlink" title="26.?? 的作用"></a>26.?? 的作用</h3><p>可选值的默认值, 当可选值为nil 的时候, 会返回后面的值. 如</p>
<p>let someValue &#x3D; optional1 ?? 0</p>
<h3 id="27-lazy-的作用"><a href="#27-lazy-的作用" class="headerlink" title="27.lazy 的作用"></a>27.lazy 的作用</h3><p>懒加载, 当属性要使用的时候, 才去完成初始化</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LazyClass &#123;</span><br><span class="line">    lazy var someLazyValue: Int = &#123;</span><br><span class="line">        print(&quot;lazy init value&quot;)</span><br><span class="line">        return 1</span><br><span class="line">    &#125;()</span><br><span class="line">    var someNormalValue: Int = &#123;</span><br><span class="line">        print(&quot;normal init value&quot;)</span><br><span class="line">        return 2</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let lazyInstance = LazyClass()</span><br><span class="line">print(lazyInstance.someNormalValue)</span><br><span class="line">print(lazyInstance.someLazyValue)</span><br></pre></td></tr></table></figure>

<h3 id="28-一个类型表示选项，可以同时有几个选项选中（类似-UIViewAnimationOptions-），用什么类型表示"><a href="#28-一个类型表示选项，可以同时有几个选项选中（类似-UIViewAnimationOptions-），用什么类型表示" class="headerlink" title="28.一个类型表示选项，可以同时有几个选项选中（类似 UIViewAnimationOptions ），用什么类型表示"></a>28.一个类型表示选项，可以同时有几个选项选中（类似 UIViewAnimationOptions ），用什么类型表示</h3><p>需要实现自 OptionSet ，一般使用 struct 实现。由于 OptionSet 要求一个不可失败的 init(rawValue:) 构造器，而枚举无法做到这一点（枚举的原始值构造器是可以失败的，而且有些组合值，是没办法用一个枚举值表示的）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct SomeOption: OptionSet &#123;</span><br><span class="line">    let rawValue: Int</span><br><span class="line">    static let option1 = SomeOption(rawValue: 1 &lt;&lt; 0)</span><br><span class="line">    static let option2 = SomeOption(rawValue: 1 &lt;&lt; 1)</span><br><span class="line">    static let option3 = SomeOption(rawValue: 1 &lt;&lt; 2)</span><br><span class="line">&#125;</span><br><span class="line">let options: SomeOption = [.option1, .option2]</span><br></pre></td></tr></table></figure>

<h3 id="29-inout-的作用"><a href="#29-inout-的作用" class="headerlink" title="29.inout 的作用"></a>29.inout 的作用</h3><p>输入输出参数更改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func swap(a: inout Int, b: inout Int) &#123;</span><br><span class="line">    let temp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = 1</span><br><span class="line">var b = 2</span><br><span class="line">print(a,b) // 1 2</span><br><span class="line">swap(&amp;a, &amp;b)</span><br><span class="line">print(a,b) // 2 1</span><br></pre></td></tr></table></figure>

<h3 id="30-Error-如果要兼容-NSError-需要做什么操作"><a href="#30-Error-如果要兼容-NSError-需要做什么操作" class="headerlink" title="30.Error 如果要兼容 NSError 需要做什么操作"></a>30.Error 如果要兼容 NSError 需要做什么操作</h3><p>其实直接转换就可以, 例如 SomeError.someError as NSError 但是这样没有错误码, 描述等等, 如果想和 NSError 一样有这些东西, 只需要实现 LocalizedError 和 CustomNSError 协议, 有些方法有默认实现, 可以略过, 如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">enum SomeError: Error, LocalizedError, CustomNSError &#123;</span><br><span class="line">    case error1, error2</span><br><span class="line">    public var errorDescription: String? &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .error1:</span><br><span class="line">            return &quot;error description error1&quot;</span><br><span class="line">        case .error2:</span><br><span class="line">            return &quot;error description error2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var errorCode: Int &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .error1:</span><br><span class="line">            return 1</span><br><span class="line">        case .error2:</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static var errorDomain: String &#123;</span><br><span class="line">        return &quot;error domain SomeError&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    public var errorUserInfo: [String : Any] &#123;</span><br><span class="line">        switch self &#123;</span><br><span class="line">        case .error1:</span><br><span class="line">            return [&quot;info&quot;: &quot;error1&quot;]</span><br><span class="line">        case .error2:</span><br><span class="line">            return [&quot;info&quot;: &quot;error2&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(SomeError.error1 as NSError)</span><br></pre></td></tr></table></figure>

<h3 id="31-下面的代码用到了哪些语法糖-1-2-3-map-0-2"><a href="#31-下面的代码用到了哪些语法糖-1-2-3-map-0-2" class="headerlink" title="31.下面的代码用到了哪些语法糖 [1,2,3].map {$0 * 2}"></a>31.下面的代码用到了哪些语法糖 [1,2,3].map {$0 * 2}</h3><p>1.[1,2,3]使用了 Array 实现的 ExpressibleByArrayLiteral 协议, 用于接收数组的字面值</p>
<p>2.map{xxx} 使用了闭包。</p>
<p>作为最后一个参数时, 可以直接写在调用后面, 而且, 如果是唯一参数的话, 圆括号也可以省略<br>闭包没有声明函数参数, 返回值类型, 数量, 依靠的是闭包类型的自动推断<br>闭包中语句只有一句时, 自动将这一句的结果作为返回值 $0 在没有声明参数列表的时候, 第一个参数名称为$0, 后续参数以此类推</p>
<h3 id="32-什么是高阶函数"><a href="#32-什么是高阶函数" class="headerlink" title="32.什么是高阶函数"></a>32.什么是高阶函数</h3><p>一个板书如果可以以某一个函数作为函数，或者返回值，那么这个函数就称之为高阶函数<br>如: map、reduce、filter</p>
<h3 id="33-如何解决引用循环"><a href="#33-如何解决引用循环" class="headerlink" title="33.如何解决引用循环"></a>33.如何解决引用循环</h3><p>转换为值类型，只有类会存在引用循环，所以如果能不是类可以解决引用循环<br>delegate 使用weak 属性<br>闭包中，对有可能发生循环引用的对象，使用 weak 或者 unowned 修饰</p>
<h3 id="34-下面的代码会不会崩溃，说出原因"><a href="#34-下面的代码会不会崩溃，说出原因" class="headerlink" title="34. 下面的代码会不会崩溃，说出原因"></a>34. 下面的代码会不会崩溃，说出原因</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var mutableArray = [1,2,3]</span><br><span class="line">for _ in mutableArray &#123;</span><br><span class="line">    mutableArray.removeLast()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不会，for in 开始时对 mutableArray 进行一次补货，而 Array 是值类型，removeLast() 并不能修改捕获的值</p>
<h3 id="35-给集合中的元素是字符串的类型增加一个扩展方法，应该怎么生命"><a href="#35-给集合中的元素是字符串的类型增加一个扩展方法，应该怎么生命" class="headerlink" title="35.给集合中的元素是字符串的类型增加一个扩展方法，应该怎么生命"></a>35.给集合中的元素是字符串的类型增加一个扩展方法，应该怎么生命</h3><p>使用 where 子句，限制 Element 为 String</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extension Array where Element == String &#123;</span><br><span class="line">    var isStringElement:Bool &#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[&quot;1&quot;,&quot;2&quot;].isStringElement</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="36-定义静态方法时关键词-static-和-calss-有什么区别"><a href="#36-定义静态方法时关键词-static-和-calss-有什么区别" class="headerlink" title="36.定义静态方法时关键词 static 和 calss 有什么区别"></a>36.定义静态方法时关键词 static 和 calss 有什么区别</h3><p>static 定义的方法 不可以被子类集成，calss 可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class AnotherClass &#123;</span><br><span class="line">    static func staticMethod() &#123;&#125;</span><br><span class="line">    class func classMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ChildOfAnotherClass: AnotherClass &#123;</span><br><span class="line">    override class func classMethod() &#123;&#125;</span><br><span class="line">//    override static func staticMethod() &#123;&#125; // error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="37-一个-Sequence-的索引是不是一定从-0-开始的？"><a href="#37-一个-Sequence-的索引是不是一定从-0-开始的？" class="headerlink" title="37. 一个 Sequence 的索引是不是一定从 0 开始的？"></a>37. 一个 Sequence 的索引是不是一定从 0 开始的？</h3><p>不一定，两个for in 并不能保证都是0开始的，且输出结果一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for element in sequence &#123;</span><br><span class="line">    if ... some condition &#123; break &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for element in sequence &#123;</span><br><span class="line">    // No defined behavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct Countdowm: Sequence, IteratorProtocol &#123;</span><br><span class="line">    var count: Int</span><br><span class="line">    </span><br><span class="line">    mutating func next() -&gt; Int? &#123;</span><br><span class="line">        if count == 0 &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            defer &#123;</span><br><span class="line">                count -= 1</span><br><span class="line">            &#125;</span><br><span class="line">            return count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let threeToGo = Countdowm(count: 3)</span><br><span class="line">print(&quot;begin 1&quot;)</span><br><span class="line">for i in threeToGo &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;end 1&quot;)</span><br><span class="line"></span><br><span class="line">print(&quot;begin 2&quot;)</span><br><span class="line">for i in threeToGo &#123;</span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">print(&quot;end 2&quot;)</span><br></pre></td></tr></table></figure>

<p>从结果看，第二次是没有任何输出的。在第二次进行 for in 时 count 没有重置</p>
<h3 id="38-数组都实现了哪些协议"><a href="#38-数组都实现了哪些协议" class="headerlink" title="38.数组都实现了哪些协议"></a>38.数组都实现了哪些协议</h3><p>MutableCollection 实现了可修改的数组 如 a[1] &#x3D; 2<br>ExpressibleByArrayLiteral 实现了数组可以从 [1,2,3] 这种字面值初始化的能力<br>…</p>
<h3 id="39-如何自定义模式匹配"><a href="#39-如何自定义模式匹配" class="headerlink" title="39.如何自定义模式匹配"></a>39.如何自定义模式匹配</h3><p>参考喵神 swfit tips<br><a target="_blank" rel="noopener" href="http://swifter.tips/pattern-match/">http://swifter.tips/pattern-match/</a></p>
<h3 id="40-autoclosure-的作用"><a href="#40-autoclosure-的作用" class="headerlink" title="40.autoclosure 的作用"></a>40.autoclosure 的作用</h3><p>自动闭包，会自动将一个表达式封装为闭包。如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func autoClosureFunction(_ closure: @autoclosure () -&gt; Int) &#123;</span><br><span class="line">    closure()</span><br><span class="line">&#125;</span><br><span class="line">autoClosureFunction(1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考喵神 swfit tips<br><a target="_blank" rel="noopener" href="http://swifter.tips/autoclosure/">http://swifter.tips/autoclosure/</a></p>
<h3 id="41-编译选项-whole-mode-optmization-优化了什么"><a href="#41-编译选项-whole-mode-optmization-优化了什么" class="headerlink" title="41.编译选项 whole mode optmization 优化了什么"></a>41.编译选项 whole mode optmization 优化了什么</h3><ul>
<li>编译器可以跨文件优化编译代码，不局限于一个文件</li>
<li>优化了编译编译，执行速度</li>
</ul>
<h3 id="42-下面代码中-mutating-的作用是什么"><a href="#42-下面代码中-mutating-的作用是什么" class="headerlink" title="42.下面代码中 mutating 的作用是什么"></a>42.下面代码中 mutating 的作用是什么</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Person &#123;</span><br><span class="line">    var name: String &#123;</span><br><span class="line">        mutating get &#123;</span><br><span class="line">            return store</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mutating 表示有可能修改这个结构体，所以只有 var 对象才可以调用</p>
<h3 id="43-如何让自定义对象支持字面量初始化"><a href="#43-如何让自定义对象支持字面量初始化" class="headerlink" title="43.如何让自定义对象支持字面量初始化"></a>43.如何让自定义对象支持字面量初始化</h3><p>有几个协议, 分别是<br>ExpressibleByArrayLiteral 可以由数组形式初始化<br>ExpressibleByDictionaryLiteral 可以由字典形式初始化<br>ExpressibleByNilLiteral 可以由nil 值初始化<br>ExpressibleByIntegerLiteral 可以由整数值初始化<br>ExpressibleByFloatLiteral 可以由浮点数初始化<br>ExpressibleByBooleanLiteral 可以由布尔值初始化<br>ExpressibleByUnicodeScalarLiteral<br>ExpressibleByExtendedGraphemeClusterLiteral<br>ExpressibleByStringLiteral<br>这三种都是由字符串初始化, 上面两种包含有 Unicode 字符和特殊字符</p>
<h3 id="44-dynamic-framework-和-static-framework-的区别是什么"><a href="#44-dynamic-framework-和-static-framework-的区别是什么" class="headerlink" title="44.dynamic framework 和 static framework 的区别是什么"></a>44.dynamic framework 和 static framework 的区别是什么</h3><p>静态库和动态库, 静态库是每一个程序单独打包一份, 而动态库则是多个程序之间共享</p>
<h3 id="45-为什么数组索引越界会崩溃，而字典用下标取值时-key-没有对应值的话返回的是-nil-不会崩溃"><a href="#45-为什么数组索引越界会崩溃，而字典用下标取值时-key-没有对应值的话返回的是-nil-不会崩溃" class="headerlink" title="45.为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃"></a>45.为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃</h3><p>数组的对象的储蓄地址是连续的，如果越界了，那取到的地址不一定可用，所以报错。毕竟还是需要有可以信任的部分的</p>
<h3 id="46-一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。"><a href="#46-一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。" class="headerlink" title="46.一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。"></a>46.一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func isNumber&lt;T : SignedNumber&gt;(_ number : T)&#123;</span><br><span class="line">    print(&quot;yes, it is a number&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>面试题来源 ： 卓同学的 Swift 面试题<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7c7f4b4e4efe">https://www.jianshu.com/p/7c7f4b4e4efe</a></p>
<p>答案参考： yww 答《卓同学的 Swift 面试题》上,下<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/23d99f434281">https://www.jianshu.com/p/23d99f434281</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cc4a737ddc1d">https://www.jianshu.com/p/cc4a737ddc1d</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/swift/" rel="tag"># swift</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2018/05/23/20180417/" rel="prev" title="18年东京周边之旅">
      <i class="fa fa-chevron-left"></i> 18年东京周边之旅
    </a></div>
      <div class="post-nav-item">
    <a href="/2018/06/06/20180606/" rel="next" title="理解和分析 APP Crash Reports">
      理解和分析 APP Crash Reports <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-class-%E5%92%8C-struct-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">1.class 和 struct 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%B8%8D%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%EF%BC%88%E5%85%B1%E4%BA%AB%EF%BC%89%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">2.</span> <span class="nav-text">2.不通过继承，代码复用（共享）的方式有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-set-%E7%8B%AC%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">3.</span> <span class="nav-text">3.set 独有的方法有哪些</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-min-%E5%87%BD%E6%95%B0%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E8%BE%83%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-number">4.</span> <span class="nav-text">4.实现一个 min 函数，返回两个元素较小的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-map%E3%80%81filter%E3%80%81reduce-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">5.map、filter、reduce 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-map-%E4%B8%8E-flatmap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.</span> <span class="nav-text">6.map 与 flatmap 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AF-copy-on-write"><span class="nav-number">7.</span> <span class="nav-text">7.什么是 copy on write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BB%A3%E7%A0%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E8%A1%8C%E5%8F%B7"><span class="nav-number">8.</span> <span class="nav-text">8.如何获取当前代码的函数名和行号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%A6%82%E4%BD%95%E7%94%9F%E5%91%BD%E4%B8%80%E4%B8%AA%E5%8F%AA%E8%83%BD%E8%A2%AB%E7%B1%BB-conform-%E7%9A%84-protocol"><span class="nav-number">9.</span> <span class="nav-text">9.如何生命一个只能被类 conform 的 protocol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-guard-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">10.</span> <span class="nav-text">10. guard 使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-defer-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">11.</span> <span class="nav-text">11. defer 使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-String-%E4%B8%8E-NSString-%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">12.</span> <span class="nav-text">12. String 与 NSString 的关系和区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA-String-%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="nav-number">13.</span> <span class="nav-text">13.怎么获取一个 String 的长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%A6%82%E4%BD%95%E6%88%AA%E5%8F%96-String-%E7%9A%84%E6%9F%90%E6%AE%B5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">14.</span> <span class="nav-text">14.如何截取 String 的某段字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-throws-%E5%92%8C-rethrows-%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E4%BD%9C%E7%94%A8"><span class="nav-number">15.</span> <span class="nav-text">15. throws 和 rethrows 的用法与作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-try-%E5%92%8C-try%EF%BC%81%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="nav-number">16.</span> <span class="nav-text">16.try? 和 try！是什么意思</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-associatedtype-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">17.</span> <span class="nav-text">17. associatedtype 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-final"><span class="nav-number">18.</span> <span class="nav-text">18.什么时候使用 final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-public-%E5%92%8C-open-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">19.public 和 open 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E7%94%9F%E5%91%BD%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AD%E5%8C%85%E7%9A%84%E5%88%AB%E5%90%8D"><span class="nav-number">20.</span> <span class="nav-text">20.生命一个只有一个参数没有返回值闭包的别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-Self-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">21.</span> <span class="nav-text">21.Self 的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-Dynamic-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">22.</span> <span class="nav-text">22.Dynamic 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-objc"><span class="nav-number">23.</span> <span class="nav-text">23.什么时候使用 @objc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-Optional-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">24.</span> <span class="nav-text">24.Optional 是怎么实现的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8B%E6%A0%87%E8%8E%B7%E5%8F%96"><span class="nav-number">25.</span> <span class="nav-text">25.如何自定义下标获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">26.</span> <span class="nav-text">26.?? 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-lazy-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">27.</span> <span class="nav-text">27.lazy 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA%E9%80%89%E9%A1%B9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E6%9C%89%E5%87%A0%E4%B8%AA%E9%80%89%E9%A1%B9%E9%80%89%E4%B8%AD%EF%BC%88%E7%B1%BB%E4%BC%BC-UIViewAnimationOptions-%EF%BC%89%EF%BC%8C%E7%94%A8%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E8%A1%A8%E7%A4%BA"><span class="nav-number">28.</span> <span class="nav-text">28.一个类型表示选项，可以同时有几个选项选中（类似 UIViewAnimationOptions ），用什么类型表示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-inout-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">29.</span> <span class="nav-text">29.inout 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#30-Error-%E5%A6%82%E6%9E%9C%E8%A6%81%E5%85%BC%E5%AE%B9-NSError-%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C"><span class="nav-number">30.</span> <span class="nav-text">30.Error 如果要兼容 NSError 需要做什么操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AF%AD%E6%B3%95%E7%B3%96-1-2-3-map-0-2"><span class="nav-number">31.</span> <span class="nav-text">31.下面的代码用到了哪些语法糖 [1,2,3].map {$0 * 2}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32-%E4%BB%80%E4%B9%88%E6%98%AF%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">32.</span> <span class="nav-text">32.什么是高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF"><span class="nav-number">33.</span> <span class="nav-text">33.如何解决引用循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%8C%E8%AF%B4%E5%87%BA%E5%8E%9F%E5%9B%A0"><span class="nav-number">34.</span> <span class="nav-text">34. 下面的代码会不会崩溃，说出原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-%E7%BB%99%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%EF%BC%8C%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E7%94%9F%E5%91%BD"><span class="nav-number">35.</span> <span class="nav-text">35.给集合中的元素是字符串的类型增加一个扩展方法，应该怎么生命</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%97%B6%E5%85%B3%E9%94%AE%E8%AF%8D-static-%E5%92%8C-calss-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">36.定义静态方法时关键词 static 和 calss 有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#37-%E4%B8%80%E4%B8%AA-Sequence-%E7%9A%84%E7%B4%A2%E5%BC%95%E6%98%AF%E4%B8%8D%E6%98%AF%E4%B8%80%E5%AE%9A%E4%BB%8E-0-%E5%BC%80%E5%A7%8B%E7%9A%84%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">37. 一个 Sequence 的索引是不是一定从 0 开始的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-%E6%95%B0%E7%BB%84%E9%83%BD%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE"><span class="nav-number">38.</span> <span class="nav-text">38.数组都实现了哪些协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">39.</span> <span class="nav-text">39.如何自定义模式匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-autoclosure-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">40.</span> <span class="nav-text">40.autoclosure 的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9-whole-mode-optmization-%E4%BC%98%E5%8C%96%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">41.</span> <span class="nav-text">41.编译选项 whole mode optmization 优化了什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%E4%B8%AD-mutating-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">42.</span> <span class="nav-text">42.下面代码中 mutating 的作用是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E5%A6%82%E4%BD%95%E8%AE%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%94%AF%E6%8C%81%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">43.</span> <span class="nav-text">43.如何让自定义对象支持字面量初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-dynamic-framework-%E5%92%8C-static-framework-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">44.</span> <span class="nav-text">44.dynamic framework 和 static framework 的区别是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#45-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%E4%BC%9A%E5%B4%A9%E6%BA%83%EF%BC%8C%E8%80%8C%E5%AD%97%E5%85%B8%E7%94%A8%E4%B8%8B%E6%A0%87%E5%8F%96%E5%80%BC%E6%97%B6-key-%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%BA%94%E5%80%BC%E7%9A%84%E8%AF%9D%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF-nil-%E4%B8%8D%E4%BC%9A%E5%B4%A9%E6%BA%83"><span class="nav-number">45.</span> <span class="nav-text">45.为什么数组索引越界会崩溃，而字典用下标取值时 key 没有对应值的话返回的是 nil 不会崩溃</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#46-%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%8F%AA%E8%A6%81%E6%98%AF%E6%95%B0%E5%AD%97%EF%BC%88Int%E3%80%81Float%EF%BC%89%E9%83%BD%E5%8F%AF%E4%BB%A5%EF%BC%8C%E8%A6%81%E6%80%8E%E4%B9%88%E8%A1%A8%E7%A4%BA%E3%80%82"><span class="nav-number">46.</span> <span class="nav-text">46.一个函数的参数类型只要是数字（Int、Float）都可以，要怎么表示。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">47.</span> <span class="nav-text">备注</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="neal"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">neal</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:nealsherlock@gmail.com" title="E-Mail → mailto:nealsherlock@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">neal</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
